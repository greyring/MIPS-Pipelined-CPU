#include "arch.h"
#include "keyboard.h"
#include "syscall.h"

unsigned char scantoascii_uppercase[] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x7E, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x51,
    0x21, 0xff, 0xff, 0xff, 0x5a, 0x53, 0x41, 0x57, 0x40, 0xff, 0xff, 0x43, 0x58, 0x44, 0x45, 0x24, 0x23, 0xff, 0xff, 0x20, 0x56, 0x46,
    0x54, 0x52, 0x25, 0xff, 0xff, 0x4e, 0x42, 0x48, 0x47, 0x59, 0x5E, 0xff, 0xff, 0xff, 0x4d, 0x4a, 0x55, 0x26, 0x2A, 0xff, 0xff, 0x3c,
    0x4b, 0x49, 0x4f, 0x29, 0x28, 0xff, 0xff, 0x3E, 0x3f, 0x4c, 0x3A, 0x50, 0x5F, 0xff, 0xff, 0xff, 0x22, 0xff, 0x7B, 0x2B, 0xff, 0xff,
    0xff, 0xff, 0x0a, 0x7D, 0xff, 0x7C, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1B, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
unsigned char scantoascii_lowercase[] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x60, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x71,
    0x31, 0xff, 0xff, 0xff, 0x7a, 0x73, 0x61, 0x77, 0x32, 0xff, 0xff, 0x63, 0x78, 0x64, 0x65, 0x34, 0x33, 0xff, 0xff, 0x20, 0x76, 0x66,
    0x74, 0x72, 0x35, 0xff, 0xff, 0x6e, 0x62, 0x68, 0x67, 0x79, 0x36, 0xff, 0xff, 0xff, 0x6d, 0x6a, 0x75, 0x37, 0x38, 0xff, 0xff, 0x2c,
    0x6b, 0x69, 0x6f, 0x30, 0x39, 0xff, 0xff, 0x2e, 0x2f, 0x6c, 0x3b, 0x70, 0x2d, 0xff, 0xff, 0xff, 0x27, 0xff, 0x5b, 0x3d, 0xff, 0xff,
    0xff, 0xff, 0x0a, 0x5d, 0xff, 0x5c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1B, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

//0 for up, 1 for down
unsigned char __attribute__((section (".data"))) key_state[16] = {0};
unsigned char __attribute__((section (".data"))) skey_state[16] = {0};//special key

static int __attribute__((section (".data"))) keyboard_state = 1;//KEY_WAIT;
static int __attribute__((section (".data"))) capslock = CAP_UP;

unsigned short __attribute__((section (".data"))) keybuf[32] = {0};
unsigned long  __attribute__((section (".data"))) keybuf_head = 0;
unsigned long  __attribute__((section (".data"))) keybuf_tail = 0;

void init_keybuf()
{
    keybuf_head = 31;
    keybuf_tail = 0;
}

static __inline__ void send_to_keybuf(unsigned short key)
{
    if (key == 0xff) return;
    if (((keybuf_head + 2)&0x1f) == keybuf_tail) return;
    keybuf_head = (keybuf_head + 1)&0x1f;
    keybuf[keybuf_head] = key;
    _put_char(key);
}

unsigned char get_from_keybuf()
{
    unsigned char key;
    if (((keybuf_head + 1)&0x1f) == keybuf_tail) return 0xff;
    key = keybuf[keybuf_tail];
    keybuf_tail = (keybuf_tail + 1)&0x1f;
    return key;
}

void handle_keyboard()
{
    unsigned char key;
    key = *(unsigned char *)(KEY_ADDR);

    switch(keyboard_state)
    {
        case KEY_WAIT:
        {
            if (key == 0xe0) keyboard_state = KEY_SPECIAL;
            else if (key == 0xf0) keyboard_state = KEY_RELEASE;
            else
            {
                set_key_state(key);
                if (key == CAPS_SC)
                {
                    switch(capslock)
                    {
                        case CAP_UP     : capslock = CAP_DOWN; break;
                        case CAP_DOWN   : capslock = CAP_DOWN; break;
                        case CAP_RELEASE: capslock = CAP_UP;   break;
                    }
                }

                if (capslock | get_key_state(LSHIFT_SC) | get_key_state(RSHIFT_SC))
                {
                    send_to_keybuf(scantoascii_uppercase[key]);
                }
                else
                    send_to_keybuf(scantoascii_lowercase[key]);
                
                keyboard_state = KEY_WAIT;
            }
            break;
        }

        case KEY_RELEASE:
        {
            clr_key_state(key);
            if (key == CAPS_SC)
            {
                if (capslock == CAP_DOWN) capslock = CAP_RELEASE;
                else capslock = CAP_UP;
            }
            keyboard_state = KEY_WAIT;
            break;
        }

        case KEY_SPECIAL:
        {
            if (key == 0xf0) keyboard_state = KEY_SPRELEASE;
            else
            {
                set_skey_state(key);
                keyboard_state = KEY_WAIT;
            }
            break;
        }

        case KEY_SPRELEASE:
        {
            clr_skey_state(key);
            keyboard_state = KEY_WAIT;
            break;
        }
    }
}